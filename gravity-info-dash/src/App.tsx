import React, { useEffect, useState } from 'react';
import './App.css';
import {
  Spinner,
  CardBody,
  CardTitle,
  Card,
  CardSubtitle,
  Table,
} from "reactstrap";
import { Attestation, BatchFees, BatchTransaction, ChainTotalSupplyNumbers, Erc20Metadata, EthInfo, GravityInfo, DepositWithMetadata, TransactionBatch, VolumeInfo } from './types';

// 5 seconds
const UPDATE_TIME = 5000;

const BACKEND_PORT = 9000;
export const SERVER_URL =
  "https://" + window.location.hostname + ":" + BACKEND_PORT + "/";

function App() {
  document.title = "Gravity Bridge Info"
  const [gravityBridgeInfo, setGravityBridgeInfo] = useState<GravityInfo | null>(null);
  const [ethBridgeInfo, setEthBridgeInfo] = useState<EthInfo | null>(null);
  const [supplyInfo, setSupplyInfo] = useState<ChainTotalSupplyNumbers | null>(null);
  const [erc20Metadata, setErc20Metadata] = useState<Array<Erc20Metadata> | null>(null);
  const [volumeInfo, setVolumeInfo] = useState<VolumeInfo | null>(null);

  async function getGravityInfo() {
    let request_url = SERVER_URL + "gravity_bridge_info";
    const requestOptions: any = {
      method: "GET",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
      },
    };

    const result = await fetch(request_url, requestOptions);
    const json = await result.json();
    setGravityBridgeInfo(json)
  }
  async function getEthInfo() {
    let request_url = SERVER_URL + "eth_bridge_info";
    const requestOptions: any = {
      method: "GET",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
      },
    };

    const result = await fetch(request_url, requestOptions);
    const json: EthInfo = await result.json();
    // reverse so these show up in reverse cronological order
    json.batch_events.reverse()
    json.deposit_events.reverse()
    json.logic_calls.reverse()
    json.valset_updates.reverse()
    setEthBridgeInfo(json)
  }
  async function getDistributionInfo() {
    let request_url = SERVER_URL + "supply_info";
    const requestOptions: any = {
      method: "GET",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
      },
    };

    const result = await fetch(request_url, requestOptions);
    const json = await result.json();
    setSupplyInfo(json)
  }
  async function getErc20Metadata() {
    let request_url = SERVER_URL + "erc20_metadata";
    const requestOptions: any = {
      method: "GET",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
      },
    };

    const result = await fetch(request_url, requestOptions);
    const json = await result.json();
    setErc20Metadata(json)
  }
  async function getVolumeInfo() {
    let request_url = SERVER_URL + "bridge_volume";
    const requestOptions: any = {
      method: "GET",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
      },
    };

    const result = await fetch(request_url, requestOptions);
    const json = await result.json();
    setVolumeInfo(json)
  }


  useEffect(() => {
    getDistributionInfo();
    getGravityInfo();
    getEthInfo();
    getErc20Metadata();
    getVolumeInfo();
    //eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  useEffect(() => {
    const interval = setInterval(() => {
      getDistributionInfo();
      getGravityInfo();
      getEthInfo();
      getErc20Metadata();
      getVolumeInfo();
    }, UPDATE_TIME);
    return () => clearInterval(interval);
    //eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  if (gravityBridgeInfo == null || typeof (gravityBridgeInfo) === "string" || ethBridgeInfo == null || supplyInfo == null || typeof (supplyInfo) === "string" || erc20Metadata == null || volumeInfo == null || typeof (volumeInfo) === "string") {
    return (
      <div className="App-header" style={{ display: "flex", flexWrap: "wrap" }}>
        <Spinner
          color="danger"
          type="grow"
        >
          Loading...
        </Spinner>
      </div>
    )
  }

  let bridge_address = gravityBridgeInfo.params.bridge_ethereum_address;
  let etherscanBase = "https://etherscan.io/address/"
  let etherscanBlockBase = "https://etherscan.io/block/"
  let etherscanLink = etherscanBase + bridge_address;

  return (
    <div className="App-header" style={{ display: "flex", flexWrap: "wrap" }}>
      <div style={{ padding: 5 }}>
        <Card className="ParametersCard" style={{ borderRadius: 8, padding: 20 }}>
          <CardBody>
            <CardTitle tag="h4">
              Transaction Queue
            </CardTitle>
            <CardSubtitle
              style={{ fontSize: 15 }}
            >These transactions are not yet in batches, a batch will be reqested when the fee amount exceeds the cost to execute on Ethereum</CardSubtitle>
            <Table
              style={{ borderSpacing: 10, fontSize: 15 }}
            >
              <thead>
                <tr>
                  <th>
                    Token
                  </th>
                  <th>
                    Num Transactions
                  </th>
                  <th>
                    Total Fees
                  </th>
                </tr>
              </thead>
              <tbody>
                {
                  gravityBridgeInfo.pending_tx.map((batchFees: BatchFees) => (<tr>
                    <td>
                      {getMetadataFromList(batchFees.token, erc20Metadata)?.symbol}
                    </td>
                    <td>
                      {batchFees.tx_count}
                    </td>
                    <td>
                      {amountToFraction(batchFees.token, batchFees.total_fees, erc20Metadata)}
                    </td>

                  </tr>))
                }

              </tbody>
            </Table>
          </CardBody>
        </Card>
      </div>
      <div style={{ padding: 5 }}>
        <Card className="ParametersCard" style={{ borderRadius: 8, padding: 20 }}>
          <CardBody>
            <CardTitle tag="h4">
              Batch Queue
            </CardTitle>
            <CardSubtitle
              style={{ fontSize: 15 }}
            >These transactions are in batches and waiting to be relayed to Ethereum</CardSubtitle>
            {
              getNotExecutedBatches(gravityBridgeInfo, ethBridgeInfo).map((batch: TransactionBatch) => (<Card>
                <CardBody>
                  <CardTitle tag="h5"> Batch #{batch.nonce}  {getMetadataFromList(batch.token_contract, erc20Metadata)?.symbol}</CardTitle>
                  <div style={{ fontSize: 15 }}>Total Fees: {amountToFraction(batch.token_contract, batch.total_fee.amount, erc20Metadata)}</div>
                  <div style={{ fontSize: 15 }}>Timeout: <a href={etherscanBlockBase + batch.batch_timeout}>{batch.batch_timeout}</a></div>
                  <Table
                    style={{ borderSpacing: 10, fontSize: 15 }}
                  >
                    <thead>
                      <tr>
                        <th>
                          To
                        </th>
                        <th>
                          From
                        </th>
                        <th>
                          Amount / Fee
                        </th>
                      </tr>
                    </thead>
                    <tbody>
                      {
                        batch.transactions.map((batchTx: BatchTransaction) => (<tr>
                          <td>
                            <a href={etherscanBase + batchTx.destination}>{batchTx.destination}</a>
                          </td>
                          <td>
                            <a href={cosmosAddressToExplorerLink(batchTx.sender)}>{batchTx.sender}</a>
                          </td>
                          <td>
                            {amountToFraction(batchTx.erc20_token.contract, batchTx.erc20_token.amount, erc20Metadata)}/
                            {amountToFraction(batchTx.erc20_token.contract, batchTx.erc20_fee.amount, erc20Metadata)}
                          </td>
                        </tr>))
                      }

                    </tbody>
                  </Table>
                </CardBody>
              </Card>))
            }
          </CardBody>
        </Card>
      </div>
      <div style={{ padding: 5 }}>
        <Card className="ParametersCard" style={{ borderRadius: 8, padding: 20 }}>
          <CardBody>
            <CardTitle tag="h4">
              Incoming transactions
            </CardTitle>
            <Table
              style={{ borderSpacing: 10, fontSize: 15 }}
            >
              <thead>
                <tr>
                  <th>
                    Token
                  </th>
                  <th>
                    Value
                  </th>
                  <th>
                    Source
                  </th>
                  <th>
                    Destination
                  </th>
                  <th>
                    Status
                  </th>
                </tr>
              </thead>
              <tbody>
                {
                  ethBridgeInfo.deposit_events.map((sendToCosmos: DepositWithMetadata) => (<tr>
                    <td>
                      {getMetadataFromList(sendToCosmos.erc20, erc20Metadata)?.symbol}
                    </td>
                    <td>
                      {amountToFraction(sendToCosmos.erc20, sendToCosmos.amount, erc20Metadata)}
                    </td>
                    <td>
                      <a href={etherscanBase + sendToCosmos.sender}>{sendToCosmos.sender}</a>
                    </td>
                    <td>
                      <a href={cosmosAddressToExplorerLink(sendToCosmos.destination)}>{sendToCosmos.destination}</a>
                    </td>
                    <td>
                      {printTxStatus(sendToCosmos, gravityBridgeInfo.attestations)}
                    </td>

                  </tr>))
                }

              </tbody>
            </Table>
          </CardBody>
        </Card>
      </div>
      <div style={{ padding: 5 }}>
        <Card className="ParametersCard" style={{ borderRadius: 8, padding: 25 }}>
          <CardBody>
            <CardTitle tag="h4">
              Gravity Volume
            </CardTitle>
            <div style={{ fontSize: 15 }}>Daily Volume ${(volumeInfo.daily_volume / 10 ** 6).toFixed(2)}M</div>
            <div style={{ fontSize: 15 }}>Daily Inflow ${(volumeInfo.daily_inflow / 10 ** 6).toFixed(2)}M</div>
            <div style={{ fontSize: 15 }}>Daily Outflow ${(volumeInfo.daily_outflow / 10 ** 6).toFixed(2)}M</div>
            <div style={{ fontSize: 15 }}>Weekly Volume ${(volumeInfo.weekly_volume / 10 ** 6).toFixed(2)}M</div>
            <div style={{ fontSize: 15 }}>Weekly Inflow ${(volumeInfo.weekly_inflow / 10 ** 6).toFixed(2)}M</div>
            <div style={{ fontSize: 15 }}>Weekly Outflow ${(volumeInfo.weekly_outflow / 10 ** 6).toFixed(2)}M</div>
          </CardBody>
        </Card>
      </div>
      <div style={{ padding: 5 }}>
        <Card className="ParametersCard" style={{ borderRadius: 8, padding: 25 }}>
          <CardBody>
            <CardTitle tag="h4">
              Gravity Supply Info
            </CardTitle>
            <div style={{ fontSize: 15 }}>Total Supply: {(supplyInfo.total_supply / 10 ** 12).toFixed(2)}M Graviton</div>
            <div style={{ fontSize: 15 }}>Community Pool: {(supplyInfo.community_pool / 10 ** 12).toFixed(2)}M Graviton</div>
            <div style={{ fontSize: 15 }}>Liquid (Not Vesting): {(supplyInfo.total_liquid_supply / 10 ** 12).toFixed(2)}M Graviton</div>
            <div style={{ fontSize: 15 }}>Liquid (Not Vesting) and staked: {(supplyInfo.total_nonvesting_staked / 10 ** 12).toFixed(2)}M Graviton</div>
            <div style={{ fontSize: 15 }}>Unclaimed staking rewards: {(supplyInfo.total_unclaimed_rewards / 10 ** 12).toFixed(2)}M Graviton</div>
            <div style={{ fontSize: 15 }}>Unvested: {(supplyInfo.total_vesting / 10 ** 12).toFixed(2)}M Graviton</div>
            <div style={{ fontSize: 15 }}>Unvested Staked: {(supplyInfo.total_vesting_staked / 10 ** 12).toFixed(2)}M Graviton</div>
            <div style={{ fontSize: 15 }}>Vested: {(supplyInfo.total_vested / 10 ** 12).toFixed(2)}M Graviton</div>
          </CardBody>
        </Card>
      </div>
      <div style={{ padding: 5 }}>
        <Card className="ParametersCard" style={{ borderRadius: 8, padding: 25 }}>
          <CardBody>
            <CardTitle tag="h4">
              Current Gravity Parameters
            </CardTitle>
            <div style={{ fontSize: 15 }}>Ethereum Contract Address: <a href={etherscanLink}>{bridge_address}</a></div>
            <div style={{ fontSize: 15 }}>Bridge Active: {String(gravityBridgeInfo.params.bridge_active)}</div>
            <div style={{ fontSize: 15 }}>Target Batch Timeout: {(gravityBridgeInfo.params.target_batch_timeout / 1000) / (60 * 60)} hours</div>
          </CardBody>
        </Card>
      </div>

    </div >
  );
}

/// Inefficient utility function to lookup token metadata, should be using a map
/// of some kind
function getMetadataFromList(erc20: string, metadata: Array<Erc20Metadata>) {
  var arrayLength = metadata.length;
  for (var i = 0; i < arrayLength; i++) {
    if (metadata[i].address === erc20) {
      return metadata[i]
    }
  }
  return null
}

/// returns a readable fraction value for a given erc20 amount, if the exchange rate is populated
/// it is used to display token value / dollar value
function amountToFraction(erc20: string, amount: number, metadata: Array<Erc20Metadata>) {
  let tokenInfo = getMetadataFromList(erc20, metadata);
  if (tokenInfo == null) {
    return 0
  }
  let fraction = amount / 10 ** tokenInfo.decimals;
  if (tokenInfo.exchange_rate == null) {
    return fraction.toFixed(2);
  } else {
    let dollar_value = fraction * (tokenInfo.exchange_rate / 10 ** 6);
    return "$" + dollar_value.toFixed(2)
  }
}

/// Takes both info structs to cross compare and display batches that have not yet been
/// executed without waiting 20 minutes for Gravity to know that a batch has been executed
/// on Ethereum
function getNotExecutedBatches(gravityBridgeInfo: GravityInfo, ethBridgeInfo: EthInfo) {
  let ret = [];
  var arrayLength = gravityBridgeInfo.pending_batches.length;
  for (var i = 0; i < arrayLength; i++) {
    if (!alreadyExecuted(gravityBridgeInfo.pending_batches[i].nonce, ethBridgeInfo)) {
      ret.push(gravityBridgeInfo.pending_batches[i])
    }
  }
  return ret
}

/// Checks if a batch has already executed on Ethereum but GB does not
/// know it yet by searching the eth events history
function alreadyExecuted(batch_nonce: number, ethBridgeInfo: EthInfo) {
  var arrayLength = ethBridgeInfo.batch_events.length;
  for (var i = 0; i < arrayLength; i++) {
    if (ethBridgeInfo.batch_events[i].batch_nonce === batch_nonce) {
      return true
    }
  }
  return false
}

/// Takes various cosmos addresses to create a proper mintscan link
function cosmosAddressToExplorerLink(input: string) {
  let gravBase = "https://mintscan.io/gravity-bridge/account/"
  let osmoBase = "https://mintscan.io/osmosis/account/"
  let crescentBase = "https://mintscan.io/crescent/account/"
  let cantoBase = "https://explorer.nodestake.top/canto/account/"
  let mantleBase = "https://mintscan.io/mantle/account/"
  if (input.startsWith("gravity")) {
    return gravBase + input
  } else if (input.startsWith("canto")) {
    return cantoBase + input
  } else if (input.startsWith("osmosis")) {
    return osmoBase + input
  } else if (input.startsWith("cre")) {
    return crescentBase + input
  } else if (input.startsWith("mantle")) {
    return mantleBase + input
  } else {
    return input
  }
}

// takes a send to Cosmos event and determines its status
function printTxStatus(event: DepositWithMetadata, events: Array<Attestation>) {
  if(event.confirmed) {
    return "Complete" 
  } else {
    return "Pending " + event.seconds_until_confirmed + "s"
  }
}

export default App;